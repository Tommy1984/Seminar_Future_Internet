\documentclass{semdoc}

% Template: $Id: t01_txt.tex,v 1.7 2000/05/23 12:13:37 bless Exp $
% -----------------------------------------------------------------------------
% Seminarbeitrag
% -----------------------------------------------------------------------------
% Kommentare beginnen mit einem %-Zeichen
\docbegin
% --> Oberhalb der Linie bitte nichts ändern.
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% Stellen, an denen etwas geändert werden soll, sind wie hier gekennzeichnet.
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
\newtheorem{Def}{Definition}
\newtheorem{Bsp}{Beispiel} 
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% --> Bitte den Titel des Beitrages in die nächste Zeile eintragen:
\title{Seminararbeit - R3: Resilient Routing Reconfiguration}
%
% --> ... und den Namen des Autors:
\author{Thomas Bersch}
% --> optional eine URL mailto:... oder http://www...
\authorURL{}
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
%
%
\maketitle
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% --> ... und jetzt kommt die Zusammenfassung:
\begin{abstract}

Die Wiederherstellung der Erreichbarkeit von Netzknoten nach dem Ausfall eines 
Netzwerk-Links ist eine wichtige Aufgabe heutiger Routing-Protokolle. 
Weiterführende, oder daraus resultierende Problem werden von heutigen Verfahren 
jedoch oft außer Acht gelassen.
Routing Resiliency Rekonfiguration (R3) von Wang et al. \cite{tD2_WWMA10} ist 
ein neuer Ansatz, der es ermöglicht einige dieser Problem zu berücksichtigen. 
R3 kann zum einen Staufreiheit nach Link-Ausfällen garantieren, ist flexibel an 
verschiedene Leistungsanforderung anpassbar und ist robust gegenüber 
variierender Netzbelastung oder sich ändernde Netztopologie. Außerdem 
erfordert R3 nur geringen Berechnungs- und Speicheraufwand für die eingesetzten 
Router.  

\end{abstract}
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
% ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG
% -----------------------------------------------------------------------------
% --> Im Text sollte \section der "höchste" Gliederungsbefehl sein,
%     also bitte kein \chapter oder gar \part verwenden.
%     Der Text kann aber mit \section{}, \subsection{}, \subsubsection{}
%     untergliedert werden.
%
%     Bitte _neue_ Rechtschreibung verwenden!
%
%     Bitte nicht die Befehle \input oder \include verwenden, also den
%     Text _nicht_ in mehrere Dateien aufteilen! 
%
%     \newpage oder manuelle Zeilenumbürche (\\) sollten ebenfalls nicht 
%     verwendet werden.
%
%     Bitte darauf achten, dass im _Quelltext_ ein Abschnitt nicht nur 
%     in einer Zeile steht (das macht z.B. Word beim Exportieren ohne
%     Zeilenumbruch), der Abschnitt sollte auch bei 80 Zeichen pro Zeile
%     noch lesbar sein, d.h. Zeilenumbrche im Quelltext bitte entsprechend
%     einfgen.
%
%     Referenzen auf andere Abschnitte sind bitte mit \ref{...}, wie 
%     anschliessend gezeigt, anzugeben und nicht etwa als Text wie
%     "siehe auch Abschnitt 2.2"
%
%     Anführungszeichen sind nicht einfach so "Text" einzugeben, sondern so:
%     "`Text"', andernfalls gibt es Fehler.
%
%     Das Zeichen ~ erzeugt einen Leerraum an dem aber nicht getrennt wird.
%     Weitere Trennstellen:
%     "- = zustzliche Trennstelle
%     "| = Vermeidung von Ligaturen und mgliche Trennung (bsp: Schaf"|fell)
%     "~ = Bindestrich an dem keine Trennung erlaubt ist (bsp: bergauf und "~ab)
%     "= = Bindestrich bei dem Worte vor und dahinter getrennt werden drfen
%     "" = Trennstelle ohne Erzeugung eines Trennstrichs (bsp: und/""oder)
%
%     Weiterer Hinweis: 
%     KEIN Glossar erstellen! Abkrzungen sind im Text zu erklren!
%     Der Text ist mit z.B. mit ispell auf Schreibfehler zu prfen 
%     (am besten aus dem Emacs heraus, 
%     Men: Edit -> Spell -> Select Deutsch8, dann Edit -> Spell -> Check Buffer)
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 

%------------------------------------------------------------------------------
% Kapitel - Einleitung
%------------------------------------------------------------------------------
\section{Einleitung}
\label{tD2_Einleitung}
Heutige Computernetze, wie beispielsweise das IP-basierte Internet, bestehen in 
der Regel aus vielen einzelnen Netzknoten. Diese sind nicht notwendigerweise 
direkt, sondern über mehrere Knoten hinweg miteinander verbunden. 
In diesem Fall spricht man von einem vermaschten Netz.
Um Information über das Netz zu entfernten Knoten zu übertragen, müssen 
diese von den dazwischen liegenden Netzknoten solange weitergereicht werden, 
bis der Zielknoten erreicht wird.
Die Wahl der zu verwendeten Zwischensysteme, also die Wahl eines Weges durch 
das Netz wird als Routing bezeichnet.
Da in aller Regel mehrere Weg zu Verfügung stehen, ist die Optimierung des 
Weges bezüglich eine Metrik, wie z.B der kürzeste Weg, oder die aktuelle 
Netzauslastung ein wichtiger Aspekt beim Routing.

Neben der Optimierung des Weges spielt beim Routing ein weiterer Aspekt ein 
wichtige Rolle. 
Über die Zeit hinweg kann sich ein Netztopologie ständig ändern, wodurch zuvor 
gefunden Routen ungültig und neue gesucht werden müssen. Grunde dafür sind 
beispielsweise der Ausfall eines Netzknotens, das Ändern von Routing-Metriken, 
die aktuelle Netzauslastung etc..
Um auf solche Situationen reagieren zu können, müssen die Router die 
Netztopologie beobachten und Informationen über dessen aktuellen Zustand 
austauschen.
Hierfür gibt es eine Reihe von Routing-Protokollen wie beispielsweise die im 
Internet eingesetzten Protokolle Routing Information Protokoll (RIP) 
\cite{tD2_RFC2453}, Open Shortest Path First (OSPF) \cite{tD2_RFC2328} oder 
Intermediate System - Intermediate System (IS-IS) \cite{tD2_RFC1142}. 
Eine wichtige Eigenschaft in diesem Zusammenhang ist 
\textit{Network Resiliency} \cite{tD2_WWMA10}.
Mit Network Resiliency wird Fähigkeit eines Netzes Netzwerks bezeichnet, 
sich schnell und problemlos nach einer Reihen von Fehlern oder Unterbrechungen 
zu reorganisieren und eine Datenübertragung wieder zu ermöglichen.
Viele Verfahren legen dabei vorwiegend Wert auf die Wiederherstellung der 
Verfügbarkeit eines oder mehrerer Netzknoten.
Weitergehende Problem, die z.B aus der Umgehung defekter Links hervorgehen 
können, werden häufig außer acht gelassen. Dazu zählt vorwiegend die 
Mehrbelastung des verbliebenen Netzwerks durch die verminderte Netzkapazität 
und den umgeleiteten Verkehr.
Iyer at al. \cite{tD2_Iyer03} führt dies als eine der Hauptursache für das 
Auftreten von Stausituation in IP-basierten Netzen an.
Ein weiterer, oft nicht berücksichtigter Aspekt ist die fehlende Möglichkeit, 
Aussagen über die Leistungsfähigkeit des Netzes nach dem Ausfall eines Links zu 
treffen. 

Eine Schwierigkeit bei der Entwicklung von Routing-Verfahren die auch die oben 
genannten Probleme berücksichtigen, ist die Vielzahl möglicher Fehlerszenarien. 
Bei einem Netz mit 500 Links sind bei 3 Link-Fehlern schon über 20 Millionen 
Szenarien möglich. Die Berücksichtigung jedes dieser Szenarien 
bedeutet i.d.R ein zu hohen Berechnungsaufwand. 
Um aber eben beispielsweise Staufreiheit nach einem Link-Fehler garantieren zu 
können, muss eine Aussage für jedes Szenario getroffen werden.  

Das von Wang et al. \cite{tD2_WWMA10} entwickelte Verfahren 
Routing Resiliency Reconfiguration (R3) ist ein neues Verfahren, um sowohl 
ein Routing für den Normalbetrieb ohne Fehler, als auch ein Protection Routing 
für den Fall eines oder mehrere Link-Ausfälle zu berechnen und nach jedem 
Fehler auf die momentane Netztopologie anzupassen. Dazu wird ein Ansatz 
vorgestellt, der die Berücksichtigung aller möglichen Fehlerszenarien vermeidet.
Weiterhin wird gezeigt, dass das Verfahren Staufreiheit durch Link-Ausfälle 
garantieren kann. Zudem wird gezeigt, dass das Verfahren effizient in Hinsicht 
auf Berechnungs-Overhead und Speicherverbrauch ist, es flexibel an verschieden 
Leistungsanforderungen (z.B zur Einhaltung von Service Level Agreements) 
angepasst werden kann und robust gegenüber Änderungen der Netzauslastung oder 
der Netztopologie ist.


%------------------------------------------------------------------------------
% Kapitel - Grundlagen
%------------------------------------------------------------------------------
\section{Grundlagen}
\label{tD2_Grundlagen}
Neben der Pfadbasierten Auffassung von Routings, ist es auch möglich Routing 
als Fluss aufzufassen \cite{tD2_ApCo03} und das zugrundeliegende 
Computernetzwerk als Flussnetzwerk zu betrachten.
Häufig ist eine Pfad (Route) von einer Quelle zur Senke nicht eindeutig, 
sondner es gibt mehrer Pfade für das Paar aus Quell und Senke. 
Für die Datenübertragung kann nicht nur einer dieser Pfade, sondern auch 
mehrere unterschiedliche gleichzeitig genutzt werden. 
Jeder Pfad überträgt dann einen gewissen Anteil der zu übermittelnden 
Informationen.
Fasst man das Netzwerk als gerichteten Graph $G=(V,E)$ auf, wobei $V$ der 
Menge der Router und $E$ der Menge der Netzwerkverbindungen zwischen den 
Routern entspircht, lässt sich so ein Flussnetzwerk definieren.
Die Werte $r_{ab}(e)$ geben dazu jeweils den Anteil einer Übertragung von 
$a \in V$ nach $b \in V$ an, der über die Verbindung $e \in E$ geroutet wird.
Als Menge $\{r_{ab}(e)|a,b \in V \land e \in E\}$ zusammengefasst beschreiben 
diese Werte so das gesammte Routing $r$.
Der Beitrag zur Auslastung einer Verbindung $e$ entspricht dem Produkt 
$d_{ab}r_{ab}(e)$, wobei $d_{ab}$ dem aktuell von Sender $a$ initiierte Verkehr 
zum Empfänger $b$ entpsicht und $r_{ab}(e)$ der wie oben beschriebene Anteil.
Ein so definiertes Routing gilt als korrekt wenn es die in \cite{tD2_WWMA10} 
definierten Bedingungen erfüllt. Nachfolgend sidn diese Bedungen nocheinmal 
aufgeführt. 
\begin{Def}
Ein Routing $r$ ist korrekt, wenn $r$ die nachfolgenden Bedinungen erfüllt:
%TODO Quellenangabe einfügen
\begin{eqnarray}
 \begin{array}{rl}
	\mbox{[R1]} & \forall i \neq a,b: \sum_{(i,j) \in E} r_{ab}(i,j) = \sum_{(j,i) \in E} r_ab(j,i) \\ 
	\mbox{[R2]} & \sum_{(a,i) \in E} r_{ab}(a,i) = 1 \\
	\mbox{[R3]} & \forall(i,a) \in E : r_{ab}(i,a) = 0 \\
	\mbox{[R4]} & \forall e \in E : 0 \le r_{ab}(e) \le 1
 \end{array}
 \label{tD2_RoutingConstraints}
\end{eqnarray}
\end{Def}
Die erste Bedingung entspricht dem für Flussnetzwerke üblichen Flusserhalt und 
fordert, dass jeder Zwischenknoten genausoviel weiterleitet wie in ihn gesendet 
wird.
Die zweite Bedingung fordert, dass der gesamte von einer Quelle initierte 
Verkehr weitergeleitet wird, während die dritte Bedingung verbietet, dass ein 
Teil davon wieder zur Quelle zurückgesendet wird.
Die vierte Bedinung fordert, dass der weitergeleitete Anteil zwischen $0\%$ und 
$100\%$ liegt.

Alternativ zum klassischen IP-Routing gibt es auch andere Verfahren zur 
Weiterleitung von Dateneinheiten innerhalb eines Netzwerks.
Ein Beispiel, welches auch in \cite{tD2_WWMA10} als Implementierungsgrundlage 
von R3 verwendet wird, ist Multiprotolkoll-Label-Switching (MPSL) 
\cite{tD2_RFC3031}. MPLS ist ein Verfahren, welches eine verbindungsorientierte 
Datenübertragung auch in ansonsten verbindungslosen Netzen ermöglicht. 
Während beim klassichen Routing auf Schicht 3 jeder Router erneut den 
nächsten Knoten (Next Hop) für eine Dateneinheit bestimmen muss, wird bei MPLS 
zu Beginn einer Übertragung jede Dateneinheit einer Weiterleitungsklasse 
(Forwarding Equivalent Class - FEC) zugeordnet, die den Pfad 
(Lable Switch Path - LSP) durch das Netz bestimmt. 
Dazu wird ihr eine kurze Kennung fester Länge, ein sog. Label zugeordnet. 
Die nachfolgenden Knoten können anhand dieses Labels aus einer Tabelle 
(Incoming Lable Map - ILM) den nächsten Knoten bestimmen. 
Eine Auswertung des kompletten Paketkopfes ist nicht mehr notwendig.
MPSL biete außerdem die Möglichkeit einem Paket auch mehr als ein Label 
zuzuordnen. 
Dazu werden die Labels auf einem Stack, dem Lable-Stack abgelegt. 
Ein Router kann neue Labels auf dem Stack ablegen. 
Für die Auswertung des nächstens Routers wird immer das oberste Stackelement 
herangezogen. 
Ist der nächste Router der aktuelle Router, muss das Label wieder vom Stack 
entfernt werden.
Der Label-Stack von MPLS wird in \cite{tD2_WWMA10} zu Implementierung von R3 
verwendet.

Solgange die Urspüngliche Netztopologie besteht, kann das reguläre Routing 
(d.h bereits berechnete Routen) verwendet werden. 
Bei Link-Ausfällen ist dieses Routing nicht mehr gültig und muss angepasst 
werden. 
Dazu existieren unterschieldiche Verfahren, sog. Routing Protection Schemes. 
Ein häufig genutztes Verfahren ist das in \cite{tD2_RFC5714} für IP definierte 
Fast-Rerotuing.
Wird bei der Paketübertragung ein Netzwerkfehler von einem Router erkannt, 
muss für den ursprünglichen Pfad eine Alternative gefunden werden, 
die die ausgefallenen Netzkomponenten nicht verwendet. 
Solange ist keine Übertragung möglich.
Die Dauer dieser Unterbrechung setzt sich dabei zusammen, aus der Zeit bis der 
Fehler erkannt wird, der Zeit bis der lokale Router auf den Fehler reagiert, 
die Zeit bis die Informationen über den Fehler an die anderen Router 
weitergeleitet ist, der Zeit zur Neuberechnung der Routing-Tabellen 
und der Zeit um die Routing-Tabellen in die Hardware zu übertragen.
Um nun diese Ausfallzeit möglichst kurz zu halten, 
verwendet Fast-Rerouting eine schon vorab berechnete alternative Route 
um die ausgefallenen Komponenten zu umgehen.
Dadurch kann die Ausfallzeit eiens Netzknoten und damit die Verzögerung von 
Dateneinheiten auf die Erkennung des Fehlers am lokalen Router und das 
aktivieren der Alterniv-Route beschränkt werden. 
Eine Information der anderen Router im Netz ist nicht zwingen erforderlich.
Für MPLS gibt es eine ähnlich arbeitenden Variante die in \cite{tD2_RFC4090} 
beschrieben wird.

Leider kann auch mit FRR nicht sichergestellt werden, 
dass es aufgrund ausgefallener Links und dadurch umgeleiten Netzwerkverkehr 
zu Stausitutation kommt. 
Wang et al. \cite{tD2_WWMA10} definiert dazu das folgende Problem.
\begin{Def} 
(Routing Resiliency) Das Problem Routing Resiliency besteht darin, sowohl ein 
Routing $r$ als auch ein Protection Routing $p$ zu berechnen, so dass die 
Maximale Link Auslastung für bis zu F Link-Fehlern unter 100\% bleibt.
\end{Def}

Bisherige Arbeiten zum diesem Thema behandeln meist nur eine Seite, 
entweder \textit{Routing im Fehlerfall} oder 
\textit{Routing für sich ändernde Netzauslastungen}.
Das Hauptaugenmerk bei Routing im Fehlerfall liegt dabei in aller Regel auf 
der Ausfallzeit und wie dieser minimiert werden kann. 
Ein häufig verwender Ansatz ist die Vorbrechnung von Alternativ-Routen und 
das schnell Umschalten im Fehlerfall. 
Dieser Ansatz bietet allerdings noch keine Möglichkeit um Stausituation zu 
vermeiden oder die vorraussichtliche Leistung nach einem Link-Fehler zu 
bestimmen.
Alternativ zu Vorberechnung können bestehende Routen auch nach jedem Fehler 
angepasst und optimiert werden. 
Der Vorteil besteht darin, dass die neuen Routen jeweils auf die aktuelle 
Netztopologie angepasst sind und diese optimal auslasten können.
Der Nachteil liegt in der schlechteren Reaktionszeit. 
Mitunter kann die Reorganisation des Routings für die neue Netztopology sehr 
aufwendig zu berechnen und einzurichten sein.
Ein anderes Aspekt mit dem sich viele Arbeiten befassen ist die Tatsache, 
dass sich die Verkehrssituationen in einem Netz wie beispielweise dem Internet 
sehr häufig ändern und man daher ein Routing benötigt, welches dies 
berücksichtigt.

Mit R3 hat Wang et al. ein Ansatz vorgestellt, der beide Aspekte berücksichtigt.

%------------------------------------------------------------------------------
% Kapitel - Resilient Routing Reconfiguration
%------------------------------------------------------------------------------
\section{Resilient Routing Reconfiguration}
\label{tD2_R3}

Wie in Abschnitt \ref{tD2_Einleitung} erwähnt, besteht ein Problem beim 
Entwickeln von Routing-Protection-Schemes in der Vielzahl möglicher 
Fehlerszenarien und der daraus resultierenden Unkenntnis der genauen 
Netztopologie.
Für ein Netz mit $|E|$ Links und bis zu $F$ Link-Fehlern entspricht die 
Anzahl möglicher Fehlerszenarien $\sum_{i=1}^F |E| \choose i$.
Die Grundidee von R3 besteht nun darin, nicht jede dieser möglichen Topologien 
zu berücksichtigen, sondern das Problem in eine besser handhabbare Form zu 
transformieren.

Angenommen ein Link $e$ auf einem Pfad zwischen zwei Routern $a$ und $b$ in 
einem Netz $G=(V,E)$ fällt aus, so muss das verbleibende Netz 
$G'=(V, E \backslash \{e\})$ den Verkehr des ausgefallenen Links zusätzlich 
übertragen.
Diese Zusatzbelastung hängt von der aktuellen Auslastung des ausgefallenen 
Links ab, kann aber höchsten so groß wie die Kapazität $c_{e}$ des Links sein 
und wird als \textit{Virtual Demand} bezeichnet. 
So lässt sich jedem Link ein Virtual Demand entsprechend seiner Kapazität 
zuordnen. Werden alle Virtual Demands mittels Konvexkombination 
zusammengefasst, beschreibt dies den umzuleitenden Verkehr im Fehlerfall, 
unabhängig vom konkreten Fehlerszenario.
Formal kann man den Virtual Demand eines Links $e$ als Variable $x_{e}$ 
auffassen.
Für bis zu $F$ Link-Fehler überdeckt dann die Menge 
\begin{equation}
X_{F} = \{x|0 \le \frac{x_{e}}{c_{e}} \le 1 (\forall e \in V), \sum_{e \in E} \frac{x_{e}}{c_{e}} \le F\}
\label{tD2_VirtualDemandSet}
\end{equation} 
den gesamten umzuleitenden Verkehr, unabhängig vom konkreten Fehlerszenario.
Anders ausgedrückt, für jedes mögliche Fehlerszenario mit maximal $F$ 
fehlerhaften Links beschreibt $X_{F}$ den gesamten umzuleitenden Verkehr.
Anstelle eines Routings für eine konstante Verkehrsmatrix $d$ bei variabler 
Netztopologie zu berechnen, kann dadurch ein Routing für die Ursprungstopologie bei 
variablem Verkehrsaufkommen $d+X_{F}$ berechnet werden. 
Beschrieben wird das Verkehrsaufkommen $d+X_{F}$ durch die Summe des aktuellen 
Verkehrs $d$ und der Menge von Virtual Demands $X_{f}$ und entspricht 
$d+X_{f} = \{d+x|x \in X_{f}\}$.

Noch einmal zusammengefasst bedeutet dies: 
Durch die Verlagerung des Problems von der unbekannten Netztopologie (aber 
bekanntem Verkehrsaufkommen) hin zu unbekanntem Verkehrsaufkommen (aber 
bekannter Netztopologie), wird das Aufzählen aller möglichen Fehlerszenarien 
zu Berechnung eines Routings sowie Protection Routings unnötig.

Zu beachten ist allerdings, dass im Gegensatz zur endlichen Anzahl 
möglicher Netztopologien die Anzahl möglicher neuer Verkehrsmatrizen $d+X_{F}$ 
unendlich ist. 
Dies stellt jedoch kein Problem dar, da sich die Menge dieser Verkehrsmatrizen 
mittels (\ref{tD2_VirtualDemandSet}) als endliche Menge linearer Bedingungen 
formulieren lässt.
Dadurch kann lineare Optimierung zur Berechnung und Optimierung eines 
Routings $r$ und eines Protection Routings $p$ verwendet werden.
Die Aufzählung aller möglichen Verkehrsmatrizen ist dazu nicht nötig.

R3 nutzt nun diese Überlegungen als Grundlage.
Prinzipiell gliedert sich R3 in zwei Teile, einer vom Netzbetrieb unabhängigen 
Vorberechnung (Offline-Phase), die sowohl ein Routing $r$ als auch ein 
Protection Routing $p$ berechnet und einer Rekonfiguration (Online-Phase) von 
$p$ nach jedem Link-Ausfall während des eigentlichen Netzbetriebs.

\subsection{Vorberechnung (Offline-Phase)}
Aufgabe der Vorberechnungsphase ist es ein möglichst optimales Routing 
$r$ für eine gegeben Verkehrsmatrix $d$ sowie ein entsprechendes 
Protection Routing $p$ für den Virtual Demand $X_{F}$ zu berechnen.
Optimierungsziel ist dabei die Minimierung der maximalen Link-Auslastung (MLU) 
für die ursprüngliche Netztopologie und das kombinierte Verkehrsaufkommen 
$d+X_{F}$ aus aktuellem Verkehr $d$ und Virtual Demand $X_{F}$.
Wie Eingangs schon erwähnt lässt sich dieses Problem mittels linearer 
Optimierung effizient lösen.

Formal entspricht das Problem den nachfolgenden linearen Optimierungsproblem:
\begin{eqnarray}
 \begin{array}{rl}
    \mbox{\textbf{minimize}}_{(r,p)}    & MLU \\
    \mbox{\textbf{subject to:}}  	& \\
    \mbox{[C1]}         		& r = \{r_{a,b}(e)|a,b \in V, e \in E\}~\mbox{ist ein Routing nach (\ref{tD2_RoutingConstraints})} \\
					& p = \{p_{l}(e)|l,e \in E\}~\mbox{ist ein Routing nach (\ref{tD2_RoutingConstraints})} \\
    \mbox{[C2]}         		& \forall x \in X_{F}, \forall e \in E:\\
					& \frac{\sum_{a,b \in V}d_{a,b}r_{ab}(e)+\sum_{l \in E}x_{l}p_{l}(e)}{c_{e}} \le MLU
 \end{array}
 \label{tD2_LPOriginal}
\end{eqnarray}

Während [C1] sicherstellt,  dass $r$ und $p$ die Bedingungen für ein gültiges 
Routing einhalten fordert [C2], dass die Maximal-Auslastung (MLU) für jeden 
Link und jeden Virtual Demand $x \in X_{F}$ nicht überschritten wird.
In dieser Form des linearen Optimierungsproblems besteht weiterhin das Problem, 
dass es sich bei $X_{F}$ um eine nicht endliche Menge handelt 
und sich daraus unendlich viele Bedingungen ergeben.

Nun kann aber die Dualität von linearen Optimierungsproblemen ausgenutzt werden,  
um das ursprüngliche Problem \ref{tD2_LPOriginal} in das nachfolgende 
einfachere lineare Optimierungsproblem mit polynomialer Anzahl an Bedingungen 
zu transformieren.

\begin{eqnarray}
 \begin{array}{rl}
    \mbox{\textbf{minimize}}_{(r,p,\pi,\lambda)} & MLU \\
    \mbox{\textbf{subject to:}}  		 & \\
    		         			 & r = \{r_{a,b}(e)|a,b \in V, e \in E\}~\mbox{ist ein Routing nach (\ref{tD2_RoutingConstraints})} \\
						 & p = \{p_{l}(e)|l,e \in E\}~\mbox{ist ein Routing nach (\ref{tD2_RoutingConstraints})} \\
   		        			 & \forall e \ in E: \frac{\sum_{a,b \in V}d_{a,b}r_{ab}(e)+\sum_{l \in E}\pi_{e}(l)+\lambda_{e}F}{c_{e}} \le MLU \\
						 & \forall e,l \in E: \frac{\pi_{e}(l)+\lambda_{e}}{c_{l}} \ge p_{l}(e) \\
						 & \forall e,l \in E. \pi_{e}(l) \ge 0 \\
						 & \forall e \in E: \lambda_{e} \ge 0
 \end{array}
 \label{tD2_LPSimple}
\end{eqnarray}

Die Transformation zwischen (\ref{tD2_LPOriginal}) 
und (\ref{tD2_LPSimple}) ist hauptsächlich Teil der linearen Optimierung und 
wird in dieser Arbeit nicht näher behandelt. 
Für ein genau Beschreibung der Transformation siehe \cite{tD2_WWMA10}

\subsection{Rekonfiguration (Online-Phase)}
Da sich im Fehlerfall, z.B durch den Ausfall eines Links während des 
Betriebes die Netztopologie ändert, muss das von der Offline-Phase für das 
gesamte Netzwerk ermittelte Protection Routing $p$ so angepasst werden, 
dass $p$ keine ungültigen (defekten) Links verwendet. 

Nachdem ein Link-Fehler auf einem Link $e$ von einem Router erkannt wird, 
aktiviert dieser sofort sein Protection Routing $p$ und leitet den Verkehr 
entsprechen einer Routing-Alternative $\xi_{e}$ um.
Da $p$ allerdings nicht für die Topologie in diesem konkreten Fehlerfall, 
sondern auf der ursprünglichen Netztopologie definiert wurde, 
muss $p$ zuvor entsprechend des Fehlers angepasst werden, 
um sicherzustellen das der defekte Link $e$ nicht mehr verwendet wird.  
Um dies zu erreichen muss lediglich eine einfache Anpassung (re-scaling) der 
verbliebenen Links durchgeführt werden, die den Verkehr von $e$ nun mittragen 
müssen. 
Die Anpassung erfolgt nach folgender Formel:
\begin{equation}
\xi_{e}(l) = \frac{p_{e}(l)}{1-p_{e}(e)};~\forall l \in E \backslash \{e\} 
\end{equation}
Damit wird sichergestellt, dass der gesamte Verkehr auch weiterleitet wird 
und somit Routing-Bedingung [R2] in (\ref{tD2_RoutingConstraints}) gültig bleibt.

Um den fehlerhaften Link $e$ nun generell nicht mehr zu benutzen, 
müssen sowohl Routing $r$ als auch Protection Routing $p$ angepasst werden.
Dazu kann einfach der vormals an $e$ zugeteilte Verkehr auf die 
Routing-Alternative $\xi_{e}$ verteilt werden.
Der über einen Link $l \in E \backslash \{e\}$ geroutete Verkehr $r_{ab}(l)$ 
erhöht sich dann um den an ihn, durch die Umleitung $\xi_{e}$ zugeteilten 
Anteil $r_{ab}(e)\xi_{e}(l)$. Entsprechend gilt dies auch für das Protection 
Routing $p$.


\subsection{Erweiterungen}
Wang et al. beschreibt in \cite{tD2_WWMA10} einige Erweiterungen mit denen der 
Standartansatz von R3 erweitert werden kann.

Eine Erweiterung ist der Umgang mit variablen Verkehrsmatrizen, 
anstelle der wie bisher angenommen konstanten Verkehrsmatrix $d$. 

Die nächste Erweiterung ist die Behandlung von Zusammenhängenden Link-Ausfällen.
Link-Ausfälle treten nicht immer einzeln und unabhängig voneinander auf, 
sondern können in einem gewissen Zusammenhang stehen. 
Als Beispiel wird in \cite{tD2_WWMA10} der Ausfall einer von mehreren 
IP-Links gemeinsam genutzten Komponente angeben, oder das gleichzeitige 
Abschalten mehrerer Links durch den Netzbetreiber für Wartungsarbeiten. 
Wang et al. unterscheidet dazu die beiden Klassen, Shared Risk Link Group 
(SRLG) zu denen das erste Beispiel gehört und die Maintenance Link Group (MLG) 
zu der das zweite Beispiel gehört.
Eine Shared Risk Link Group besteht aus Links, die aus technischen Gründen immer 
gleichzeitig unterbrochen werden, da sie dieselben Komponenten nutzen, 
z.B. dieselbe Glasfaserleitung.
Eine MLG besteht aus Links die vom Netzbetreiber zusammengefasst werden und bei 
Wartungsarbeiten zusammen abgeschaltet werden.
R3 kann nun ergänzt werden um solche Fehlercharakteristiken zu berücksichtigen.

Eine weitere Möglichkeit von R3 besteht darin unterschiedliche Verkehrsklassen 
unterschiedlich zu behandeln. 
Dazu kann für jede Klasse, die in der Regel gewissen Service Level Agreements 
(SLA) entspricht festgelegt werden, wie viele zeitlich überlappende 
Link-Ausfälle tolleriert werden können.

Die letzten beiden vorgestellten Erweiterungen befassen sich mit dem Verhältnis 
zwischen Leistung im Normalbetrieb und Fehlerfall und mit dem Verhältnis 
zwischen Netzauslastung und Verzögerungszeit.
Da bei Ausfall eines oder mehrere Links die Netzkapazität gemindert wird und 
der Zusatzverkehr des defekten Links zusätzlich übertragen werden muss, 
müssen entsprechende Redundanz in Form von Kapazitätsreserven berücksichtigt 
werden. 
Will man im Fehlerfall weiterhin eine hohe Leistung ermöglichen, 
muss diese Redundanz entsprechend groß sein. 
Umgekehrt bedeutet dies das im Normalbetrieb nicht die bestmögliche 
Auslastung erreicht werden kann. 
Um die Auslastung für den regulären Betrieb zu beeinflussen bzw. zu verbessern,
wird das Lineare Optimierungsproblem (\ref{tD2_LPSimple}) um zusätzliche 
Bedingungen ergänzt, mit denen die Entfernung der Leistung im Normalbetrieb 
vom Optimum beeinflusst werden kann. 
Auf ähnliche Weise kann auch die für die durchschnittliche Verzögerungszeit für 
eine Ende-zu-End Übertragung beeinflusst werden. Hierzu wird 
(\ref{tD2_LPSimple}) ebenfalls durch zusätzliche Bedingungen ergänzt.


%------------------------------------------------------------------------------
% Kapitel - Implementierung
%------------------------------------------------------------------------------
\section{Implementierung}
\label{tD2_Implementierung}
Im nachfolgenden Abschnitt soll eine mögliche Implementierung von R3, 
wie sie von Wange et al. in \cite{tD2_WWMA10} vorgeschlagen wird vorgestellt 
werden.

Die Grundlage von R3 bildet die flussbasierte Darstellung des Routings.
Eine solches Routing-Schema wird von heutigen Routern allerdings noch nicht 
unterstützt, weshalb für eine Implementierung bestehende Verfahren daraufhin 
angepasst oder neue implementiert werden müssen.
Wang et al. verwendet MPLS (Linux MPLS) als Grundlage 
und gib eine darauf aufbauende Erweiterung für flussbasiertes Routing an, 
genannt MPLS-ff.

Bei reinem MPLS wählt der Router beim Eintreffen eines Paketes anhand dessen 
Label das zu verwendende Interface, über welches das Paket weitergeleitet 
werden soll.
Dazu führt der Router eine Datenstruktur in Form einer Tabelle (ILM), die für 
jedes Label eine entsprechende 
\textit{next-hop label forwarding instruction (NHLFE)} enthält. 
Da für jedes Label nur ein Eintrag vorhanden ist, wird der gesamte Verkehr der 
mit demselben Label gekennzeichnet ist auch immer über dasselbe Interface 
geroutet.
Um nun eine flussbasiertes Routing mit MPLS zu ermöglichen muss MPLS so 
erweitert werden, dass der zu einem Label gehörende Datenverkehr anteilig auf 
mehrere Interfaces verteilt  werden kann.
MPLS-ff erweitert dazu die Datenstruktur so, dass sie mehrere NHLFE Einträge 
enthalten kann. 
Außerdem wird jedem NHLFE ein Faktor (\textit{next-hop splitting ratio}) 
zugeordnet, anhand dessen der Router die Pakete wie in Abschnitt \ref{tD2_R3} 
beschrieben, auf die diesem Label zugeordneten Interfaces aufteilen kann. 

Damit Pakete die zu einer TCP-Verbindung gehören nicht unnötig über 
unterschiedliche Wege durch das Netz geschickt werden, wodurch 
Laufzeitunterschiede entstehen können, verwendet Wang et al. in 
\cite{tD2_WWMA10} eine Hashfunktion um die Pakete auf die zur Verfügung 
stehenden Links zu verteilen.
Die Hashfunktion erhält als Eingabe die Quell- und Ziel-IP, die Quell- und 
Ziel-Ports sowie eine ID, abhängig vom aktuellen Router.
Ziel der Hash-Funktion ist es, Pakete die zur selben TCP-Verbindung gehören auf 
einem Router immer denselben Hash-Wert zuzuordnen, 
für unterschiedliche Router aber unterschiedlich zu sein.
So wird erreicht, dass die Pakete einer TCP-Verbindung denselben Weg nehmen.  

%TODO Referenz zu Fehlererkennung auf Schicht 2 einfügen
Mithilfe der Erweiterung MPLS-ff kann nun R3 implementiert werden.
Die Vorberechnung des \textit{Protection Routing p} und die Einrichtung von 
MPLS-ff kann von einem zentralen Server erledigt werden.
Die Rekonfiguration während des Betriebes muss jeder Router selbst durchführen.
Zu Fehlererkennung während des Betriebs kann die Sicherungsschicht (Layer 2) 
auf Fehlerereignisse beobachtet werden. 
Auch andere Fehlererkennungsverfahren wie z.B \cite{tD2_KYGS05} sind möglich.
Wird ein fehlerhafter Link erkannt, 
werden alle andern Router mittels ICMP Pakete über den Fehler informiert, so 
dass diese entsprechend ihr Protection Routing anpassen können.
Dazu muss jeder Router die \textit{next-hop splitting ratio} für die zu dem 
ausgefallenen Link gehörenden Alternative-Links anpassen.

Um nun Pakete im Fehlerfall umzuleiten wird der Label-Stack von MPLS verwendet. 
Erkennt ein Router einen Linkfehler wird die für das Label des Paketes 
definierte Alternative-Route aktiviert.
Dazu legt der Router ein weiteres Label auf den Label-Stack des Paketes und 
ordnet es damit der Alternative-Route zu.
Das Paket wird dann entsprechend diesem Label weitergeleitet. 
Erreicht ein Paket wieder die Ursprungsroute, 
wird das neue Label wieder vom Label-Stack entfernt und kann auf normalem Weg 
weitergeleitet werden.

\begin{Bsp}
\label{tD2_ExampleFailurResponse}
Angenommen O1 und O2 wollen beide mittels eine TCP-Verbindung Daten über das 
Netzwerk an D1 übertragen.
Sei weiter angenommen, der normale Label Switch Pfad von R1 zu R3 führt über 
R2, wie in Abbildung \ref{tD2_Implementation_Example_01} gezeigt.
Trifft ein Paket bei Router R1 ein, so ordnet er diesem Paket ein Label zu, z.B 
das Label 100 für den Pfad R1-R2-R3 und leitet das Paket entsprechend weiter.

\Abbildungf{!h}{width= 0.50\textwidth}{tD2_Implementation_Example_01}{tD2_Implementation_Example_01}{Routing ohne Link-Fehler}
\Abbildungf{!h}{width= 0.50\textwidth}{tD2_Implementation_Example_02}{tD2_Implementation_Example_02}{Routing im Fehlerfall}

Kommt es nun zu einem Link-Ausfall zwischen zwischen R1 und R2, 
wie in Abbildung \ref{tD2_Implementation_Example_02} dargestellt, 
so muss R1 sein Protection Routing aktivieren 
und die Pakete entsprechend über die Alternativrouten umleiten. 
Dazu ordnet R1 anhand seiner ILM den Paketen ein neues Protection Label, 
beispielsweise 101 zu und legt es auf den Label Stack der MPLS Dateneinheit.
Für dieses Label existieren angenommen zwei NHLFE in der ILM von R1, die 
besagen, dass jeweils 50\% des Verkehrs von (R1,R2) über (R1,R4) 
und (R1,R5) übertragen werden.
Um nun Pakete für dieselbe TCP-Verbindung auch auf demselben Weg zu 
transportieren, berechnet R1 wie oben beschrieben eine Hashwert. 
Anhand dieses Wertes teilt die Pakete entsprechend für O1 an den nächsten Router 
R4 zu und die Pakete von O2 an den nächsten Router R5.
R4 und R5 leiten die Pakte dann entsprechend des Labels 101 an R2 weiter, 
wo das oberste Label 101 wieder vom Stack entfernt und auf normalem Weg weiter 
zu R3 geleitet wird. 
Ein ähnliches Beispiel findet sich auch in \cite{tD2_WWMA10}

\end{Bsp}


%------------------------------------------------------------------------------
% Kapitel - Evaluierung
%------------------------------------------------------------------------------
\section{Evaluierung}
Der nachfolgende Abschnitt gibt einen Überblick über die in \cite{tD2_WWMA10} 
vorgestellte Evaluierung von R3.
Zur Evaluierung wurden zum einen Simulationen und zum anderen die ebenfalls in 
\cite{tD2_WWMA10} vorgestellte, auf Linux MPLS basierende reale Implementierung von 
R3 verwendet. 

Die verwendeten Netztopologien zur Simulation sind zum einen die Topologie 
eines Tier-1 Internet Servie Providers (ISP) nachfolgend US-ISP genannt, und 
zum anderen die durch das Rocketfuel-Projekt \cite{tD2_SpMW02} aufgezeichneten 
Netztopologien von Level-3, SBC und UUNet, sowie einer mittels GT-ITM 
generierten Backbonetopologie.
Zur Evaluierung der experimentellen Implementierung von R3 wurde mittels Emulab 
die Backbone-Topologie des Abilene Netzwerks emuliert.

\begin{table}[!htb]  
\label{tD2_SummaryNetworks}                   
\begin{center}
\begin{tabular}{|l||r|r|}
\hline
Netz		& Knoten	& Links	\\
\hline
Abilene    	& 11		& 28 \\
Level-3		& 17		& 72 \\
SBC		& 19		& 70 \\
UUNet		& 47		& 336  \\
Generated	& 100		& 460  \\
US-ISP		& -		& - \\
\hline
\end{tabular}
\end{center}
\caption{Übersicht über die Netztopologien \cite{tD2_WWMA10}}
\end{table}

Als mögliche Fehlerszenarien wurden alle Einzel-Linkfehler sowie alle möglichen 
Zwei-Link-Fehler berücksichtigt. 
Da die Anzahl möglicher Szenarien für mehr als zwei Fehler extrem groß wird, 
wurden insgesamt 1100 verschiedene Drei- und Vier-Link-Fehler 
berücksichtigt, die zufällig ausgewählt wurden.
Gemessen wurde die Verkehrsdichte an der Stelle im Netz mit den 
geringsten Kapazitätsreserven. 
Ermittelt wurde außerdem das Verhältnis dieser gemessenen Verkehrsdichte und 
optimalem flussbasiertem Routing. Je näher dieser Wert an 1 liegt, desto besser 
ist die Leistung des verwendeten Verfahrens.

Verglichen wurden die beiden Routingverfahren OSPF und MPLS-ff im Zusammenhang 
mit den Sicherungs-Verfahren Constrained Shortest Path First (CSPF) \cite{tD2_Zieg07}, 
OSPF reconvergence (recon) \cite{tD2_WWMA10}, Failure-Carrying-Packet (FCP) 
\cite{tD2_LCRA07}, Path Splicing (PathSplicing) \cite{tD2_MEFV08}, R3 und 
Flow-based optimal link detour routing (opt) \cite{tD2_WWMA10}.


\subsection{Simulation}
Abbildung \ref{tD2_USISPMeasurement} zeigt die in\cite{tD2_WWMA10} ermittelten 
Messergebnisse der US-ISP Topologie für alle Einzel-Fehler Events, 
alle Zwei-Fehler Events und 1100 zufälligen Drei-Fehler Events. 
Angegeben ist jeweils das Leistungsverhältnis für ein Szenario. 
Die Werte wurden entsprechend ihres Leistungswertes sortiert aufsteigend 
sortiert.
In alle drei Grafiken lässt sich die gleiche Gruppierung erkennen. 
OSPF+R3, OSPF+opt, MPLS+R3 liegen immer nahe beieinander und sind dem Optimum 
am nächsten.
PSPF+CSPF, OSPF+recon und FCP bilden ebenfalls eine Gruppe  liegen ebenfalls 
eng zusammen und sind zumindest für die Extremwerte am weitesten vom Optimum 
entfernt.
PathSplicing liegt in der Regel zwischen den beiden Gruppen. 
In Zahlen ausgedrückt, ist die erste Gruppe für Einzel-Fehler Events bis zu 
30\% schlechter gegenüber dem Optimum, PathSplicing ist bis zu 100\% schlechter 
und die restlichen Verfahren sogar um bis zu 260\%.
Für Zwei-Fehler Events ist die dritte Gruppe bis zu $3,7$-mal schlechter als im 
Optimalfall möglich wäre und bis zu 94\% über dem höchsten Wert der ersten Gruppe. 
Bei Drei-Fehler Events beträgt der Abstand hingegen mindestens 50\% 

\begin{figure}[!h]
\begin{minipage}[h]{16cm}
	\centering
	\includegraphics*[width=8cm]{tD2_USISP_OneFailure} 		
\end{minipage}
\vfill
\begin{minipage}[h]{8cm}
	\centering
	\includegraphics[width=8cm]{tD2_USISP_TwoFailure}		
\end{minipage}
\hfill
\begin{minipage}[hbt]{8cm}
	\centering
	\includegraphics[width=8cm]{tD2_USISP_ThreeFailure}	
\end{minipage}
\caption{Einzel-, Zwei- und zufällige Drei-Fehler Szenarien (US-ISP)\cite{tD2_WWMA10}}
\label{tD2_USISPMeasurement}
\end{figure}

Weiterhin interessant sind die Ergebnisse für die SBC Topologie, siehe 
Abbildung \ref{tD2_SBC_ThreeFailure}.
Die Grafik zweigt ein deutlich besseres Leistungsverhältnis für 
MPLS-ff+R3 gegenüber allen anderen Verfahren. Nach Wang et al. liegt dieses 
Verhalten in der gemeinsamen Optimierung von Routing und Protection-Routing von 
MPLS-ff+R3 begründet und zeigt dessen Vorteile.

\Abbildungf{!htb}{width= 0.50\textwidth}{tD2_SBC_ThreeFailure}{tD2_SBC_ThreeFailure}{Leistungsverhältnis für Drei-Fehler Szenarien (SBC) \cite{tD2_WWMA10}}


\subsection{Reale Implementierung}
Neben der Simulation des Verhaltens verschiedener Routing-Protokolle in 
verschiedenen Topologien wurde in \cite{tD2_WWMA10} auch die Leistungsfähigkeit von 
R3 durch eine für Linux implementierten Variante von R3 evaluiert.
Bewertet wurde dabei die Zeit für die Vorberechnung (Offline-Phase) von $r$ 
und $p$, den zusätzlichen Speicheraufwand von MPLS-ff und die 
Leistungsfähigkeit des Routings.

Tabelle \ref{tD2_OfflinePhase} zeigt die ermittelten Zeiten der Offline-Phase. 
Gelöst wurde das zugrunde liegende lineare Optimierungsproblem 
(\ref{tD2_LPSimple}) mit ILOG CPLEX 10.0. Die Laufzeiten nehmen mit zunehmender 
Knoten- und Linkanzahl zu, schwanken aber über der Anzahl der Fehler.

\begin{table}[!htb]  
\label{tD2_OfflinePhase}                   
\begin{center}
\begin{tabular}{|l||r|r|r|r|r|r|}
\hline
Netz / Anzahl Link-Fehler	& \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{3} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{5} & \multicolumn{1}{c|}{6} \\
\hline
Abilene    			& 0.30		& 0.30		& 0.30		& 0.32		& 0.33		& 0.29 \\
Level-3				& 1.80		& 1.97		& 2.56		& 2.71		& 2.46		& 2.43 \\
SBC				& 1.46		& 1.76		& 1.75		& 1.76		& 1.92		& 1.91 \\
UUNet				& 1010.00	& 572.00	& 1067.00	& 810.00 	& 864.00	& 720.00 \\
Generated			& 1388.00	& 929.00	& 1971.00	& 2001.00	& 1675.00	& 2131.00 \\
US-ISP				& 21.30		& 21.90		& 21.40		& 20.10		& 22.10		& 21.80 \\
\hline
\end{tabular}
\end{center}
\caption{R3 Offline-Phase in Sekunden \cite{tD2_WWMA10}}
\end{table}
 
Eine Messung des Speicherverbrauchs ergab ein moderates Ergebnis von höchstens 
267KB für die Forwarding Information Base (UUNet) und höchstens 20MB für die 
Routing Information Base (Generated).
Zur Evaluierung der Leistungsfähigkeit von R3 wurde der Durchsatz zwischen 
jedem Sender-Empfänger Paar des Abilene Netzwerks, die Link-Auslastungen und 
die aufsummierte Verlustrate an den End-Routern gemessen. Zur Fehler-Simulation 
wurden drei Links nacheinander abgeschaltet. Diese erkennt man an der 
treppenförmig steigenden Round Trip Time einer Verbindung in Abbildung 
\ref{tD2_RTT_Measurement}. 
Eine Überlastung der Links durch R3 Rerouting konnte jedoch nicht 
festgestellt werden.
\Abbildungf{!htb}{width= 0.50\textwidth}{tD2_RTT_Measurement}{tD2_RTT_Measurement}{Round Trip Time (RTT) einer Verbindung}


%------------------------------------------------------------------------------
% Kapitel - Zusammenfassung
%------------------------------------------------------------------------------
\section{Zusammenfassung}
In dieser Arbeit wurde das von Wang et al. in \cite{tD2_WWMA10} entwickelte 
Routing Protection Verfahren \textit{Resilient Routing Reconfiguration} 
behandelt. R3 bietet die Möglichkeit sowohl Routing als auch Protection Routing 
zu berechnen und mittels Rekonfiguraton während des Netzbetriebs auf aktuelle 
Fehlerereignisse zu reagieren und das Routing entsprechend anzupassen.
Eine Stärke von R3 besteht darin, Staufreiheit für ein gewisse Anzahl zeitlich 
überlappender Fehler garantieren zu können. Den Beweise führt Wang et al. 
ebenfalls in \cite{tD2_WWMA10}. Neben der Grundlegend Arbeitsweise von R3 ist auch 
die von Wang et al. vorgeschlagene Implementierung auf 
Basis von MPLS sowie eine Zusammenfassung der Evaluationsergebnisse aus 
\cite{tD2_WWMA10} teil dieser Arbeit.

% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
% Bitte keinen Text mehr unterhalb dieser Zeile eintragen!!
% -----------------------------------------------------------------------------
%
% --> Üblicherweise wird nur die Literatur aufgelistet, die auch referenziert
%     wird. Mchte man auch nichtreferenzierte Literatur einschlieen, so
%     kann man dies mit \nocite{<citelabel>} tun.
\nocite{*}
%     In die folgende Zeile sollte die bentigte Literaturdatenbankdatei
%     eingetragen werden (im Normalfall nicht zu ndern):
\bibliography{tD2_txt}
%
\docend
%%% end of document
