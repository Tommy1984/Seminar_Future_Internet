\documentclass{semdoc}

% Template: $Id: t01_txt.tex,v 1.7 2000/05/23 12:13:37 bless Exp $
% -----------------------------------------------------------------------------
% Seminarbeitrag
% -----------------------------------------------------------------------------
% Kommentare beginnen mit einem %-Zeichen
\docbegin
% --> Oberhalb der Linie bitte nichts ändern.
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% Stellen, an denen etwas geändert werden soll, sind wie hier gekennzeichnet.
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
\newtheorem{Def}{Definition}
\newtheorem{Bsp}{Beispiel} 
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% --> Bitte den Titel des Beitrages in die nächste Zeile eintragen:
\title{Seminararbeit - R3: Resilient Routing Reconfiguration}
%
% --> ... und den Namen des Autors:
\author{Thomas Bersch}
% --> optional eine URL mailto:... oder http://www...
\authorURL{}
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
%
%
\maketitle
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 
% --> ... und jetzt kommt die Zusammenfassung:
\begin{abstract}
%TODO: Abstract einfügen
Hier steht der Abstract
\end{abstract}
% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
% ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG - ACHTUNG
% -----------------------------------------------------------------------------
% --> Im Text sollte \section der "höchste" Gliederungsbefehl sein,
%     also bitte kein \chapter oder gar \part verwenden.
%     Der Text kann aber mit \section{}, \subsection{}, \subsubsection{}
%     untergliedert werden.
%
%     Bitte _neue_ Rechtschreibung verwenden!
%
%     Bitte nicht die Befehle \input oder \include verwenden, also den
%     Text _nicht_ in mehrere Dateien aufteilen! 
%
%     \newpage oder manuelle Zeilenumbürche (\\) sollten ebenfalls nicht 
%     verwendet werden.
%
%     Bitte darauf achten, dass im _Quelltext_ ein Abschnitt nicht nur 
%     in einer Zeile steht (das macht z.B. Word beim Exportieren ohne
%     Zeilenumbruch), der Abschnitt sollte auch bei 80 Zeichen pro Zeile
%     noch lesbar sein, d.h. Zeilenumbrche im Quelltext bitte entsprechend
%     einfgen.
%
%     Referenzen auf andere Abschnitte sind bitte mit \ref{...}, wie 
%     anschliessend gezeigt, anzugeben und nicht etwa als Text wie
%     "siehe auch Abschnitt 2.2"
%
%     Anführungszeichen sind nicht einfach so "Text" einzugeben, sondern so:
%     "`Text"', andernfalls gibt es Fehler.
%
%     Das Zeichen ~ erzeugt einen Leerraum an dem aber nicht getrennt wird.
%     Weitere Trennstellen:
%     "- = zustzliche Trennstelle
%     "| = Vermeidung von Ligaturen und mgliche Trennung (bsp: Schaf"|fell)
%     "~ = Bindestrich an dem keine Trennung erlaubt ist (bsp: bergauf und "~ab)
%     "= = Bindestrich bei dem Worte vor und dahinter getrennt werden drfen
%     "" = Trennstelle ohne Erzeugung eines Trennstrichs (bsp: und/""oder)
%
%     Weiterer Hinweis: 
%     KEIN Glossar erstellen! Abkrzungen sind im Text zu erklren!
%     Der Text ist mit z.B. mit ispell auf Schreibfehler zu prfen 
%     (am besten aus dem Emacs heraus, 
%     Men: Edit -> Spell -> Select Deutsch8, dann Edit -> Spell -> Check Buffer)
%
% ---------------------------------------------------------------------------
% \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ 

%------------------------------------------------------------------------------
% Kapitel - Einleitung
%------------------------------------------------------------------------------
\section{Einleitung}
\label{tD2_Einleitung}
%TODO besserer Begriff für Netzwerkfehler (trifft nicht unbedingt genau die Sache)
Heutige Netze wie beispielsweise das  IP-basierte Internet, 
bestehen in der Regel aus einer Vielzahl einzelner Netzknoten, 
die nicht notwendigerweise direkt, 
sondern über mehrere Knoten hinweg miteinander verbunden sind.
Sollen Information zu einem entfernten Knoten transportiert werden, 
müssen diese von den dazwischen liegenden Netzknoten weitergereicht werden, 
bis sie den Zielknoten erreicht haben.
Die Wahl der zu verwendeten Zwischensysteme, 
also eines Weges wird als Routing bezeichnet.
Ein wichtiger Aspekt dabei ist die Optimierung des Weges bezüglich einer Metrik, 
wie z.B die anfallenden Kosten, der kürzeste Weg, oder die aktuelle Netzauslastung.

Ein Herausforderung beim Routings besteht darin, dass sich die Netztopology ständig ändern kann,
wodurch zuvor gefunden Routen durch das Netz ungültig werden können.
Grunde dafür sind z.B der Ausfall eines Netzknotens, 
das Ändern von Routing-Metriken, die aktuelle Netzauslastung etc..
Um auf solche Situationen reagieren zu können, 
müssen die einzelnen Router untereinander Informationen über den aktuelle Zustand des Netzes austauschen.
Hierzu gibt es eine Reihe von Routing-Protokollen 
wie beispielsweise die im Internet eingesetzten Protokolle 
Open Shortest Path First (OSPF) \cite{RFC2328} oder Intermediate System - Intermediate System (IS-IS) \cite{RFC1142}. 

%TODO Bessere Erklärung für Network resiliency
%TODO Deutscher Begriff für Network resiliency suchen
Ein wichtiger Aspekt bei der Behandlung von Netzwerkfehlern ist Network Resiliency \cite{WWMA10}.
Damit gemeint ist die Fähigkeit eines Netzes,  
schnell und problemlos von einer Reihen von Fehlern oder Unterbrechungen zu kompensieren.
Hauptaugenmerk vieler Studien und heutiger Verfahren liegt vorwiegend auf der Erreichbarkeit von Netz-Komponenten. 
Dazu zählt die Verkürzung von Ausfallzeiten bzw. die Umgehung defekter Routenabschnitte 
um die dahinterliegenden Ziele wieder erreichbar zu machen.
Weitergehende Problem wie die eventuelle Häufung von Stausituation, 
verursacht durch die verminderte Netzkapazität und den umleigleiteten Verkehr, 
sowie fehlende Vorhersagbarkeit über die geänderte Leistungsfähigkeit eines Netzes werden dabei häufig außer acht gelassen.
Das Routing, welches sich ausschließlich auf Erreichbarkeit konzentriert tatsächlich anfällig für vermehrte Stausituationen ist, 
wird ebenfalls in \cite{WWMA10} untersucht und gezeigt.

Eine Schwierigkeit bei der Entwicklung von Routing-Verfahren die auch die oben genannten Probleme berücksichtigen, 
ist die Vielzahl von möglichen Fehlerszenarian.
Geht man von einer Obergenze $F$ von möglichen Fehlern in einem Netzwerk mit $|E|$ Links aus, 
so entspricht die Anzahl der möglichen Fehlerszenarien $\sum_{i=1}^{F} {|E| \choose i}$.
Die Berücksichtigung jedes dieser Szenarien bedeutet i.d.R ein zu hochen Berechnungsaufwand, 
weshalb sich die meisten Verfahren nur auf die Wiederherstellung der Erreichbarkeit beschränken und Staufreiheit etc. außer acht lassen.

%TODO besseres Wort für Routing-Absicherung suchen
R3 - Resilient Routing Reconfiguration \cite{WWMA10} ist nun ein neuer Ansatz zur Routing-Absicherung, 
der trotz der Vielzahl von Szenarien Rechnung Staufreiheit garantieren kann.
Das Verfahren ist zudem effizient in hinsicht auf Berechnungs-Overhead und Speicherverbrauch, 
kann flxiebel an verschieden Leistungsanforderungen (z.B zur Einhaltung von Service Level Agreements) angepasst werden 
und ist robust gegenüber Änderungen der Netzauslastung oder der Netztopolgie.


%------------------------------------------------------------------------------
% Kapitel - Grundlagen
%------------------------------------------------------------------------------
\section{Grundlagen}
\label{tD2_Grundlagen}
%TODO Protectin Routing erklären, definieren
%TODO Definition Verkehrsmatrix
Mit Routing wird die Auswahl eines Weges (Route) durch ein Netzwerk bezeichnet, 
der bestimmt über welche Netzknoten eine Dateneinheit von der Quelle (Orgin) bis zum Ziel (Destination) übertragen wird.
Häufig ist eine Route nicht eindeutig, sondner es gibt mehrer Routen für das gleiche Quell/Ziel-Paar. 
Dabei kann für die Datenübertragung nicht nur ein Pfad sondern auch mehrere unterschiedliche Pfade gleichzeitig genutzt werden. 
Jeder Pfad überträgt dann einen gewissen Anteil der zu übermittelnden Informationen.
Fasst man ein IP-Netzwerk als gerichteten Graph $G=(V,E)$ auf, 
wobei $V$ der Menge der Router und $E$ der Menge der Netzwerkverbindungen zwischen den Routern entspircht, 
lässt sich eine Routing $r$ auch als Fluss auffassen \cite{ApCo03}. 
Die Werte $r_{ab}(e)$ geben dazu jeweils den Anteil einer Übertragung von $a \in V$ nach $b \in V$ an, 
der über die Verbindung $e \in E$ geroutet wird.
Als Menge $\{r_{ab}(e)|a,b \in V \land e \in E\}$ zusammengefasst beschreiben diese Werte so das gesammte Routing $r$.
Der Beitrag zur Auslastung einer Verbindung $e$ entspricht dem Produkt $d_{ab}r_{ab}(e)$, 
wobei $d_{ab}$ dem aktuell von Sender $a$ initiierte Verkehr zum Empfänger $b$ entpsicht und $r_{ab}(e)$ der wie oben beschriebene Anteil.
Ein so definiertes Routing gilt als korrekt wenn es die in \cite{WWMA10} beschiebenen Bedingungen erfüllt. 
Nachfolgend sollen diese nocheinmal aufgeführt werden.
Eine Menge $\{r_{ab}(e)\}$ ist ein korrektes Routing, wenn gilt:
\begin{Def}
Ein Routing $r$ ist gültig, wenn $r$ die nachfolgenden Bediungen [R1]-[R4] erfüllt.
%TODO Quellenangabe einfügen
\begin{eqnarray}
 \begin{array}{rl}
	\mbox{[R1]} & \forall i \neq a,b: \sum_{(i,j) \in E} r_{ab}(i,j) = \sum_{(j,i) \in E} r_ab(j,i) \\ 
	\mbox{[R2]} & \sum_{(a,i) \in E} r_{ab}(a,i) = 1 \\
	\mbox{[R3]} & \forall(i,a) \in E : r_{ab}(i,a) = 0 \\
	\mbox{[R4]} & \forall e \in E : 0 \le r_{ab}(e) \le 1
 \end{array}
 \label{tD2_RoutingConstraints}
\end{eqnarray}
\end{Def}
Die erste Bedingung entspricht dem für Flussnetzwerke üblichen Flusserhalt und fordert, 
dass jeder Zwischenknoten genausoviel weiterleitet wie in ihn hineinfließt.
Die zweite Bedingun forde, dass der gesamte von einer Quelle initierte Verkehr weitergeleitet wird,
während die dritte Bedimng verbeitet ein Teil davon wieder zur Quelle zurückgeleitet wird.
Die vierte Bedinung fordert das der weitergeleitete Anteil zwischen $0\%$ und $100\%$ liegt.


%TODO Verwandte Arbeiten, bessere Einleitung suchen.
%TODO "Routing für sich ändernde Netzauslastungen" ist das so richtig?
%TODO Referenzen einfügen
Bisherige Arbeiten zum diesem Thema behandeln meistens nur eine Seite, 
entweder \textit{Routing im Fehlerfall} oder \textit{Routing für sich ändernde Netzauslastungen}.
Das Hauptaugenmerk bei Routing im Fehlerfall liegt dabei in aller Regel auf der Ausfallzeit 
und wie dieser minimiert werden kann. 
Ein häufig verwender Ansatz ist die Vorbrechnung von Alternativ-Routen und das schnell Umschalten im Fehlerfall.
Dieser Ansatz bietet allerdings noch keine Möglichkleit um Stausituation zu vermeiden oder die vorraussichtliche Leistung zu bestimmen.
Alternatiev zu Vorberechnung können bestehende Routen auch nach jedem Fehler angepasst und optimiert werden. 
Der Vorteil besteht darin, dass die neuen Routen jeweils auf die aktuelle Netztopology angepasst sind und diese optimal auslasten können.
Der Nachteil liegt in der schlechteren Reaktionszeit. 
Mitunter kann die Reorganisation des Routings für die neue Netztopology sehr aufwendig zu berechnen und einzurichten sein.
Der andere Aspekt mit dem sich viele Arbeiten befassen ist die Tatsache, 
dass sich die Verkehrssituationen in einem Netz wie beispielweise dem Internet sehr häufig ändern 
und man daher ein Routing benötigt, was dies berücksichtigt.


%TODO MPLS - Ausführlicher?
%TODO FEC im zusammenhang mit Packet-Reihenfolge
Multiprotokol Label Switching (MPLS) \cite{RFC3031} ist ein Verfahren, 
welches eine verbindungsorientierte Datenübertragung auch in ansonsten verbindungslosen Netzen ermöglicht. 
Während beim klassichen Routing auf Schicht 3 jeder Router aufs neue den nächsten Knoten (Next Hop) für eine Dateneinheit bestimmen muss,
wird bei MPLS zu Beginn einer Übertragung jede Dateneinheit einer Weiterleitungsklasse (Forwarding Equivalent Class - FEC) zugeordnet, 
die den Pfad (Lable Switch Path - LSP) durch das Netz bestimmt. 
Dazu wird ihr ein kurze Kennung fester Länge, ein sog. Label zugeordnet. 
Die nachfolgenden Knoten können anhand dieses Labels aus einer Tabelle (Incoming Lable Map - ILM) den nächsten Knoten bestimmen. 
Eine Auswertung des kompletten Paketkopfes ist nicht mehr notwendig.
MPSL biete außerdem die Möglichkeit einem Paket auch mehr als ein Label zuzuordnen. 
Dazu werden die Labels auf einem Stack, dem Lable-Stack abgelegt. 
Ein Router kann neu Labels auf dem Stack ablegen. 
Für die Auswertung des nächstens Routers wird immer das oberste Stackelement herangezogen. 
Ist der nächste Route aktuelle Router muss das Label wieder Stack entfernt werden.
Der Label-Stack von MPLS wird später bei der Implementierung von R3 in Abschnitt \ref{tD2_Implementierung} benötigt.


%TODO Fast rerouting (FRR) - Ausführlicher?
Ein häufig genutztes Verfahren um auf Netzwerkfehler wie beispielweise der Ausfall einer Verbindung 
oder eines ganzen Netzknotens zu reagieren, 
ist das in \cite{RFC5714} für IP definierte Fast-Rerotuing.
Wird bei der Paketübertragung ein Netzwerkfehler von einem Router erkannt, 
muss für den ursprünglichen Pfad eine Alternative gefunden werden, 
die die ausgefallenen Netzkomponenten nicht verwendet. Solange ist keine Übertragung möglich.
Die Dauer dieser Unterbrechung setzt sich dabei zusammen, 
aus der Zeit bis der Fehler erkannt wird, 
der Zeit bis der lokale Router auf den Fehler reagiert, 
die Zeit bis die Informationen über den Fehler an die anderen Router weitergeleitet ist, 
der Zeit zur Neuberechnung der Routing-Tabellen 
und der Zeit um die Routing-Tabellen in die Hardware zu übertragen.
Um nun diese Ausfallzeit möglichst kurz zu halten, 
verwendet Fast-Rerouting eine schon vorab berechnete alternative Route 
um die ausgefallenen Komponenten zu umgehen.
Dadurch kann die auf die Erkennung des Fehlers am lokalen Router und das aktivieren der Alterniv-Route beschränkt werden. 
Eine Information der anderen Router im Netz ist nicht zwingen erforderlich.
Für MPLS gibt es eine ähnlich arbeitenden Variante die in \cite{RFC4090} beschrieben wird.


Leider kann auch mit FRR nicht sichergestellt werden, 
dass es aufgrund ausgefallern Links und dadurch umgeleiten Netzwerkverkehr zu Stausitutation kommt. 
Mit R3 hat Wang et al. in \cite{WWMA10} nun ein Ansatz vorgestellt, 
der es ermöglicht ein Routing Schema zu berechnen, 
das in der Lage ist für bis zu $F$ beliebige fehlerhafte Links Staufreiheit in einem Netzwerk zu garantieren.
Das zugrundeliegende Routing $r$ kann dabei vorgegeben (z.b durch OSPF) oder ebenfalls von R3 berechnet werden. 

%TODO Routing Resiliency erklären, definieren

%------------------------------------------------------------------------------
% Kapitel - Resilient Routing Reconfiguration
%------------------------------------------------------------------------------
\section{Resilient Routing Reconfiguration}
\label{tD2_R3}

Wie zuvor erwähnt besteht ein Problem beim Entwickeln von Routing-Schematas in der vielzahl möglicher Fehlerszenarien 
und der daraus resultierenden Unkenntnis der genauen Netztopologie.
Die Grundidee von R3 besteht nun darin nicht jede dieser mögliche Topologie zu berücksichtigen, 
sondern das Problem in eine besser handhabbare Form zu transformieren.

Angenommen ein Link $e$ auf einem Pfad zwischen zwei Routern $a$ und $b$ in einem Netz $G=(V,E)$ fällt aus, 
so muss das verbleibende Netz $G'=(V, E \backslash \{e\})$ zusätzlich den vormals diesen Link transportierten Verkehr übertragen.
Diese Zusatzbelastung hängt von dem aktuellen Verkehr des Links ab, 
kann aber höchsten so groß wie die Kapazität $c_{e}$ des defekten Links sein 
und wird als \textit{Virtual Demand} bezeichent. 
Ordnet man jedem Link $e \in E$ einen solchen Virtual Demand entsprechend seiner Kapaziät zu, 
dann deckt die Konvexkombination aller Virtual Demands den gesamten umzuleitenden Verkehr ab.

Ordnet man jedem Link $e \in E$ einen Variable $x_{e}$ für den Virtual Demand des Links zu
und erlaubt man bis zu $F$ fehlerhafte Links,  
dann überdeckt die Menge 
\begin{equation}
X_{F} = \{x|0 \le \frac{x_{e}}{c_{e}} \le 1 (\forall e \in V), \sum_{e \in E} \frac{x_{e}}{c_{e}} \le F\}
\label{tD2_VirtualDemandSet}
\end{equation} 
den gesamten umzuleitenden Verkehr, unabhängig vom konkreten Fehlerszenario.
Anderst ausgedrückt, 
für jedes mögliche Fehlerszenario mit maximal $F$ fehlerhaften Links enthält $X_{F}$ den gesamten umzuleitenden Verkehr.
Anstelle eines Routings für ein konstante Verkehrsmatrix $d$ bei variabler Netztopologie zu berechnen, 
kann nun ein Routing für die Origianltopologie bei variablen Verkehrsaufkommen $d+X_{F}$ berechnet werden. 
Beschrieben wird das Verkehrsaufkomme $d+X_{F}$ durch die Summe des aktuellen Verkehrs $d$ und der Menge von Virtual Demands $X_{f}$ 
und entspricht $d+X_{f} = \{d+x|x \in X_{f}\}$.
%TODO Warum ist d+X_F unendlich
Zu beachten ist hierbei, das im Gegensatz zur endlichen Anzahl möglicher Netztopologien die Anzahl möglicher neuer Verkehrsmatrizen $d+X_{F}$ leider unendlich ist. 
Dies stellt jedoch kein Problem dar, 
da sich die Menge dieser Verkehrzmatrizen mittels \ref{tD2_VirtualDemandSet} als enliche Menge linearer Bedingunge formulieren lässt.
Dadurch kann Lineare Programmierung zur Berechnung und Optimierung eines Routings $r$ und eines Protection Routings $p$ verwendet werden.
Das explizite Aufzählen der unterschiedlichen Vekehrmatrizen ist nicht notwendig.

R3 nutzt nun diese Überlegungen als Grundlage.
Prinzipiell gliedert sich R3 in zwei Teile, 
einer vom Netzbetrieb unabhängen Vorberechnung (Offline-Phase), die sowohl ein Routing $r$ als auch ein Protection Routing $p$ berechnet 
und einer ständigen Rekonfiguration (Online-Phase) von $p$ während des eigentlichen Netzbetriebs.

\subsection{Vorberechnung (Offline-Phase)}
Aufgabe der Vorberechnungsphase ist es ein möglichst optimales Routing $r$ für eine gegeben Verkehrsmatrix $d$ 
sowie ein entsprechendes Protection Routing $p$ für den Virtual Demand $X_{F}$ zu berechnen.
Optimierungssziel ist dabei die Mimimierung der Maximalen Link-Auslastung (MLU) für die originale Netztopologie 
und das kombinierten Verkehrsaufkommen $d+X_{F}$ aus aktuellem Verkehr $d$ und Virtual Demand $X_{F}$.
Wie Eingangs schon erwähnt lässt sich dieses Problem mittels Linearer Programmierung effizient lösen.

Formal entspricht das Problem den nachfolgenden linearen Programm:
\begin{eqnarray}
 \begin{array}{rl}
    \mbox{\textbf{minimize}}_{(r,p)}    & MLU \\
    \mbox{\textbf{subject to:}}  	& \\
    \mbox{[C1]}         		& r = \{r_{a,b}(e)|a,b \in V, e \in E\}~\mbox{ist ein Routing nach \ref{tD2_RoutingConstraints}} \\
					& p = \{p_{l}(e)|l,e \in E\}~\mbox{ist ein Routing nach \ref{tD2_RoutingConstraints}} \\
    \mbox{[C2]}         		& \forall x \in X_{F}, \forall e \in E:\\
					& \frac{\sum_{a,b \in V}d_{a,b}r_{ab}(e)+\sum_{l \in E}x_{l}p_{l}(e)}{c_{e}} \le MLU
 \end{array}
 \label{tD2_LPOriginal}
\end{eqnarray}

Während [C1] sicherstellt,  dass $r$ und $p$ die Bedignunge für ein gültiges Routing einhalten 
fordert [C2] , dass die Maximal-Auslastung (MLU) für jeden Link und jeden Virtual Demand $x \in X_{F}$ nicht überschritten wird.
In dieser Form des linearen Programm besteht weiterhin das Problem, 
dass es sich bei $X_{F}$ um eine nicht endliche Menge handelt 
und sich daraus auch unendlich viele Bedingungen ergeben.

Nun kann aber die Dualität von linearen Programmen ausgenutz werden,  
um das ursprüngliche Programm \ref{tD2_LPOriginal} in das nachfolgende einfachere lineares Programm
mit polynomialer Anzahl an Bedingungen zu transformieren.

\begin{eqnarray}
 \begin{array}{rl}
    \mbox{\textbf{minimize}}_{(r,p,\pi,\lambda)} & MLU \\
    \mbox{\textbf{subject to:}}  		 & \\
    		         			 & r = \{r_{a,b}(e)|a,b \in V, e \in E\}~\mbox{ist ein Routing nach \ref{tD2_RoutingConstraints}} \\
						 & p = \{p_{l}(e)|l,e \in E\}~\mbox{ist ein Routing nach \ref{tD2_RoutingConstraints}} \\
   		        			 & \forall e \ in E: \frac{\sum_{a,b \in V}d_{a,b}r_{ab}(e)+\sum_{l \in E}\pi_{e}(l)+\lambda_{e}F}{c_{e}} \le MLU \\
						 & \forall e,l \in E: \frac{\pi_{e}(l)+\lambda_{e}}{c_{l}} \ge p_{l}(e) \\
						 & \forall e,l \in E. \pi_{e}(l) \ge 0 \\
						 & \forall e \in E: \lambda_{e} \ge 0
 \end{array}
 \label{tD2_LPSimple}
\end{eqnarray}

Für ein genau Beschreibung der Transformation zwischen \ref{tD2_LPSimple} und \ref{tD2_LPSimple} siehe \cite{WWMA10}

%Dazu kann in Bedingung [C2] die Summe  $\sum_{l \in E}x_{l}p_{l}(e)$ durch die maximal mögliche Auslastung $ML(p,e)$ von $e$ für alle $x \in X_{f}$ ersetzt werden. 
%Die Bedingung bleibt dadurch äquivalent. 
%%TODO Warum beleibt die Bedingung äquivalent
%Die Suche nach $ML(p,e)$ definiert ein weiteres lineares Programm:
%\begin{eqnarray}
% \begin{array}{rl}
%    \mbox{\textbf{maximize}}_{x}    	& \sum_{l \in E}x_{l}p_{l}(e) \\
%    \mbox{\textbf{subject to:}}     	& \forall l \in E: \frac{x_{l}}{c_{l}} \le 1\\
%					& \sum_{l \in E} \frac{x_l}{c_l} \le F
% \end{array}
%\end{eqnarray}


\subsection{Rekonfiguration (Online-Phase)}
Da sich im Fehlerfall, z.B durch den Ausfall eines Links während des Betriebes die Netztopologie ändert, 
muss das von der Offline-Phase für das gesamte Netzwerk ermittelte Protection Routing $p$ so angepasst werden, 
dass $p$ keine ungültigen (defekten) Links verwendet. 

Nachdem ein Link-Fehler auf einem Link $e$ von einem Router erkannt wird, 
aktiviert dieser sofort sein Protection Routing $p$ und leitet den Verkehr entsprechen einer Routing-Alternative $\xi_{e}$ um.
Da $p$ allerdings nicht für die Topologie in diesem konkreten Fehlerfall, 
sondern auf der ursprünglichen Netztopologie definert wurde, 
muss $p$ zuvor entsprechend des Fehlers angepasst werden, 
um sicherzustellen das der defekte Link $e$ nicht mehr verwendet wird.  
Um dies zu erreichen muss lediglich eine einfache Anpassung (re-scaling) der verbliebenen Links durchgeführt werden, 
die den Verkehr von $e$ nun mittragen müssen. Die Anpassung erfolgt nach folgender Formel:
\begin{equation}
\xi_{e}(l) = \frac{p_{e}(l)}{1-p_{e}(e)};~\forall l \in E \backslash \{e\} 
\end{equation}
Damit wird sichergestellt, dass der gesamte Verkehr auch weiterleitet wird 
und somit Routing-Bedingung [R2] in \ref{tD2_RoutingConstraints} gültig bleibt.

Um den fehlerhaften Link $e$ nun generell nicht mehr zu benutzen, 
müssen sowohl Routing $r$ als auch Protection Routing $p$ angepasst werden.
Dazu kann einfach der vormals an $e$ zugeteiltet Verkehr $r_{ab}(e)$ 
bzw. $p_{ab}(e)$ auf die Routing-Alternative $xi_{e}$ verteilt werden.
Die Mehrbelastung für die betroffenen Links entspricht $r_{ab}*\xi_{e}(l);~\forall a,b \in V, \forall l \in E \backslash \{e\}$
bzw. $p_{uv}(e)*\xi_{e}(l);~\forall u,v \in E \backslash \{e\}, \forall l \in E \backslash \{e\}$.

\subsection{Erweiterungen}
%TODO Erweiterungen genauer erklären
Wang et al. bescheibt in \cite{WWMA10} einige Erweiterung mit denen der 
Standartansatz von R3 erweitert werden kann.

Eine Erweiterung ist der Umgang mit variablen Verkehrmatrizen, 
ansteller der wie bisher angenommen konstanten Verkehrsmatrix $d$. 

Die nächste Erweiterung ist die Behandlung von Zusammenhängenden Link-Ausfällen.
Link-Ausfälle treten nicht immer einzeln und unabhängig voneinander auf, sondern 
können in einem gewissen Zusammenhang stehen. Als Beispiel wird in \cite{WWMA10}
der Ausfall einer von mehreren IP-Links gemeinsam genutzen Komponente angeben, 
oder das gleichzeitige Abschalten mehrerer Links durch den Netzbetreiber für 
Wartungsarbeiten. Wang et al. unterscheidet dazu die beiden Klassen, 
Shared Risk Link Group (SRLG) zu den das erste Beispiel gehört 
und die Maintenance Link Group (MLG) zu der das zweite Beispiel gehört.
Eine Shared Risk Link Group besteht aus Links die immer gleichzeitig unterbrochen 
werden.
Eine MLG besteht aus Links die vom Netzbetrieber zu Wartungszwecken zusammen 
abgeschlaten werden.
R3 kann nun ergänzt werden um soche Fehlerkarakteristiken zu berücksichtigen.

Eine weitere Möglichkeit von R3 besteht darin unterschiedliche Verkehrsklassen 
unterschiedlich zu behandeln, indem eine Klasse mehr und die andere weniger 
gleichzeitig bestehende Fehler tolerieren kann.

Die letzten beiden vorgestellten Erweiterungen befassen sich mit dem Verhältnis 
zwischen Leistung im Normalbetrieb und Fehlerfall und mit dem Verhältnis 
zwischen Netzauslastung und Verzögerungszeit.


%------------------------------------------------------------------------------
% Kapitel - Implementierung
%------------------------------------------------------------------------------
\section{Implementierung}
\label{tD2_Implementierung}
Im nachfolgenden Abschnitt soll eine mögliche Implementierung von R3, 
wie sie von Wange et al. in \cite{WWMA10} vorgeschlagen wird vorgestellt werden.

Die Grundlage von R3 bildet die flussbasierte Darstellung des Routings.
Eine solches Routing-Schema wird von heutigen Routern allerdings noch unterstütz,
weshalb für eine Implementierung bestehende Verfahren daraufhin angepasst 
oder neue implementiert werden müssen.
Wang et al. verwendet MPLS (Linux MPLS) als Grundlage 
und gib eine darauf aufbauende Erweiterung für flussbasiertes Routing an, 
genannt MPLS-ff.

Bei reinem MPLS wählt der Router beim Eintreffen eines Paketes anhand dessen Label das zu verwendende Interface, 
über welches das Paket weitergeleitet werden soll.
Dazu führt der Router eine Datenstruktur in Form einer Tabel (ILM), 
die für jedes Label eine entsprechende "next-hop label forwarding instruction (NHLFE) enthält. 
Da für jedes Label nur ein Eintrag vorhanden ist, 
wird der gesammte Verkehr der mit demselben Lable gekennzeichnet ist auch immer über dasselbe Interface geroutet.
Um nun eine flussbasiertes Routing mit MPLS zu ermöglichen muss MPLS so erweitert werden, 
dass der zu einem Label gehörende Datenverkehr anteilig auf mehrer Interfaces verteilt  werden kann.
MPLS-ff erweitert dazu die Datenstruktur so, 
dass sie mehrere NHLFE Einträge enthalten kann. 
Außerdem wird jedem NHLFE ein Faktor (\textit{next-hop splitting ratio}) zugeordnet, 
anhand dessen der Router die Pakete wie in \ref{tD2_R3} beschrieben, 
auf die diesem Label zugeordneten Interfaces aufteilen kann. 

Damit Pakete die zu einer TCP-Verbindung gehören nicht unnötig über unterschiedliche Wege durch das Netz geschickt werden, 
wodurch Laufzeitunterschiede entstehen können, 
verwednet Wang et al. in \cite{WWMA10} ein Hashfunktion um die Pakete auf die zur Verfügung stehenden Links zu verteilen.
Die Hashfunktion erhält als Eingabe die Quell- und Ziel-IP, die Quell- und Ziel-Ports sowie eine ID, abhängig vom aktuellen Router.
Ziel der Hash-Funktion ist es, Pakten die zur selben TCP-Verbindung gehören auf einem Router immer denselben Hash-Wert zuzuordnen, 
für unterschieldiche Router aber unterschiedlich zu sein.
So wird erreicht, dass die Pakete einer TCP-Verbindung denselben Weg nehmen.  

%TODO Referenz zu Fehlererkennung auf Schicht 2 einfügen
Mithilfe der Erweiterung MPLS-ff kann nun R3 implementiert werden.
Die Vorberechnung des \textit{Protection Routing p} und die Einrichtung von MPLS-ff kann von einem zentralen Server erledigt werden.
Die Rekonfiguration während des Betriebes muss jeder Router selbst durchführen.
Zu Fehlererkennung während des Betriebs kann die Sicherungsschicht (Layer 2) auf Fehlerereignisse beobachtet werden. 
Auch andere Fehlererkennungsverfahren wie z.B \cite{KYGS05} sind möglich.
Wird ein fehlerhafter Link erkannt, 
werden alle andern Router mittels ICMP Paketen üder den Fehler informiert, 
so das diese entsprechend ihr Protection Routing anpassen können.
Dazu muss jeder Router die \textit{next-hop spitting ratio} für die zu dem ausgefallenen Link gehörenden Alternative-Links anpassen.

Um nun Pakete im Fehlerfall umzuleiten wird der Label-Stack von MPLS verwendet. 
Erkennt ein Router einen Linkfehler wird die für das Label des Paketes definierte Alternative-Route aktiviert.
Dazu pusht der Router ein weiters Label auf den Label-Stack des Paketes und ordent es damit der Alternative-Route zu.
Das Paket wird dann entsprechend diesem Lable weitergeleitet. 
Erreicht ein Paket wieder die Ursprungsroute, 
wird das neue Lable wieder vom Label-Stack entfernt und kann auf normalem Weg weitergeleitet werden.

\begin{Bsp}
\label{tD2_ExampleFailurResponse}
Angenommen O1 und O2 wollen beide mittels eine TCP-Verbindung Daten über das Netzwerk an D1 übertragen.
Sei weiter angenommen, der normale Label Switch Pfad von R1 zu R3 führt über R2, wie in \ref{tD2_Implementation_Example_01} gezeigt.
Trifft ein Paket bei Router R1 ein, so ordnet er diesem Paket ein Label zu, z.B das Label 100 für den Pfad R1-R2-R3 und leitet das Paket entsprechend weiter.

\Abbildungf{!htb}{width= 0.50\textwidth}{tD2_Implementation_Example_01}{tD2_Implementation_Example_01}{Routing ohne Link-Fehler}

Kommt es nun zu einem Link-Ausfall zwischen zwischen R1 und R2, 
wie in \ref{tD2_Implementation_Example_02} dargestellt, 
so muss R1 sein Protection Routing aktivieren 
und die Pakete entsprechend über die Alternativrouten umleiten. 
Dazu ordnet R1 anhand seiner ILM den Paketen ein neues Protection Label, 
bsw. 101 zu und legt es auf den Label Stack der MPLS Dateneinheit.
Für dieses Label existiern nun angenommen zwei NHLFE in der ILM von R1, die besagen, 
dass jeweils jeweils 50\% des Verkehrs von (R1,R2) nun über (R1,R4) und (R1,R5) übertragen werden.
Um nun Pakete für dieselbe TCP-Verbindung auch auf demselbe Weg zu transportieren, 
berechnet R1 wie oben beschieben eine Hashwert. 
Anhand dieses Wertes teilt die Pakete entprechend für O1 an den nächsten Router R4 zu 
und die Pakete von O2 an den nächsten Router R5.
R4 und R5 leiten die Pakte dann entsprechend des Labels 101 an R2 weiter, 
wo das oberste Label 101 wieder vom Stack entfernt und auf normalem Weg weiter zu R3 geleitet wird. 
Ein ähnliches Beispiel findet sich auch in \cite{WWMA10}

\Abbildungf{!htb}{width= 0.50\textwidth}{tD2_Implementation_Example_02}{tD2_Implementation_Example_02}{Routing im Fehlerfall}

\end{Bsp}


%------------------------------------------------------------------------------
% Kapitel - Evaluierung
%------------------------------------------------------------------------------
\section{Evaluierung}
Der nachfolgende Abschnitt gibt einen Überblick über die in \cite{WWMA10} 
vorgestellte Evaluierung von R3.
Zur Evaluierung wurden zum einen Simulationen und zum anderen die ebenfalls in 
\cite{WWMA10} vorgestellte, auf Linux MPLS basierende reale Implementierung von 
R3 verwendet. 

Die verwendeten Netztopologien zur Simulation sind zum einen die Topologie von 
US-ISP, einem führenden Internet Service Provieder und zum anderen die durch das 
Rocketfuel-Projekt \cite{tD2_SpMW02} aufgezeichneten Netztopologien von Level-3, 
SBC und UUNet, sowie einer mittels GT-ITM generierten Backbonetopologie.
Zur Evaluierung der experimentellen Implementierung von R3 wurde mittels Emulab 
die Backbone-Topologie des Abilene Netzwerks emuliert.
%TODO Traffic
%TODO Verkehrsdicht hier richtig?
Als mögliche Fehlerszenarien wurden alle Einzel-Linkfehler sowie alle möglichen 
Zwei-Link-Fehler berücksichtigt. 
Außerdem wurden insgesamt 1100 verschiedene Drei- und Vier-Link-Fehler 
berücksichtigt, die zufällig ausgewählt wurden.
Gemessen wurde zum einen die Verkehrsdichte, bzw die Netzwerkstauung und zum 
Anderen das Verhältnis aus Verkehrsdicht und optimalem flussbasiertem Routing.

%TODO Verfahren nochmal überarbeiten
Verglichen wurden die beiden Routingverfahren OSPF und MPLS-ff im Zusammenhang 
mit den Sicherungs-Verfahren Constrained Shortest Path First (CSPF), 
OSPF reconvergence (recon), Failur-Carring-Packet (FCP), Path Splicing 
(PathSplicing), R3 und Flow-based optimal link detour routing (opt).


\subsection{Simulation}

\subsection{Reale Implementierung}


%------------------------------------------------------------------------------
% Kapitel - Zusammenfassung
%------------------------------------------------------------------------------
\section{Zusammenfassung}





% /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ 
% -----------------------------------------------------------------------------
% Bitte keinen Text mehr unterhalb dieser Zeile eintragen!!
% -----------------------------------------------------------------------------
%
% --> Üblicherweise wird nur die Literatur aufgelistet, die auch referenziert
%     wird. Mchte man auch nichtreferenzierte Literatur einschlieen, so
%     kann man dies mit \nocite{<citelabel>} tun.
\nocite{*}
%     In die folgende Zeile sollte die bentigte Literaturdatenbankdatei
%     eingetragen werden (im Normalfall nicht zu ndern):
\bibliography{tD2_txt}
%
\docend
%%% end of document
